/**
 * check-sets: Nightly validator to ensure we have all sets present in-app.
 * - Compares PokémonTCG set IDs vs. distinct set_code in public.card_prints
 * - Returns missing/extra lists and summary
 * - Optional: fix=true triggers import-prices for missing sets (with throttle)
 *
 * Requires secrets in project:
 *   SERVICE_ROLE_KEY, PROJECT_URL, (optional) POKEMON_TCG_API_KEY
 */

const SUPABASE_URL     = Deno.env.get("PROJECT_URL") || Deno.env.get("SUPABASE_URL") || Deno.env.get("SB_URL") || "";
const SERVICE_ROLE_KEY = Deno.env.get("SERVICE_ROLE_KEY") || Deno.env.get("SB_SERVICE_ROLE_KEY") || Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") || "";
const SRK = SERVICE_ROLE_KEY;
const POKEMON_TCG_KEY  = Deno.env.get("POKEMON_TCG_API_KEY") ?? "";

if (!SUPABASE_URL || !SERVICE_ROLE_KEY) {
  throw new Error("Missing env: SERVICE_ROLE_KEY and/or PROJECT_URL (or SUPABASE_URL/SB_URL).");
}

// ---- Helpers ---------------------------------------------------------------

async function listAllSetIds(): Promise<string[]> {
  const headers: Record<string,string> = { accept: "application/json" };
  if (POKEMON_TCG_KEY.trim()) headers["X-Api-Key"] = POKEMON_TCG_KEY.trim();

  let page = 1;
  const out = new Set<string>();
  while (true) {
    const r = await fetch(`https://api.pokemontcg.io/v2/sets?pageSize=250&page=${page}`, { headers });
    if (!r.ok) throw new Error(`PTCG sets ${r.status}`);
    const j = await r.json().catch(()=> ({}));
    const arr = Array.isArray(j?.data) ? j.data : [];
    for (const s of arr) if (s?.id) out.add(String(s.id));
    if (arr.length < 250) break;
    page++;
  }
  return Array.from(out).sort();
}

async function listDbSetCodesFromCardPrints(): Promise<string[]> {
  const out = new Set<string>();
  const pageSize = 1000;
  let offset = 0;

  while (true) {
    const url = `${SUPABASE_URL}/rest/v1/card_prints?select=set_code&order=set_code&limit=${pageSize}&offset=${offset}`;
    const r = await fetch(url, {
      headers: {
        apikey: SERVICE_ROLE_KEY,
        Authorization: `Bearer ${SERVICE_ROLE_KEY}`
      }
    });
    if (!r.ok) throw new Error(`card_prints ${r.status}`);
    const arr = await r.json().catch(()=> []);
    if (!Array.isArray(arr) || arr.length === 0) break;
    for (const row of arr) if (row?.set_code) out.add(String(row.set_code));
    if (arr.length < pageSize) break;
    offset += pageSize;
  }

  return Array.from(out).sort();
}

async function writeAudit(row: any) {
  // Optional: persist a summary row if table exists
  try {
    const r = await fetch(`${SUPABASE_URL}/rest/v1/set_sync_audit`, {
      method: "POST",
      headers: {
        apikey: SERVICE_ROLE_KEY,
        Authorization: `Bearer ${SERVICE_ROLE_KEY}`,
        "content-type": "application/json",
        Prefer: "resolution=merge-duplicates"
      },
      body: JSON.stringify([row])
    });
    // ignore failure (table might not exist)
    await r.text().catch(()=>{});
  } catch { /* no-op */ }
}

async function runImportPrices(set_code: string, debug=false) {
  const url = `${SUPABASE_URL}/functions/v1/import-prices`;
  const res = await fetch(url, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      "Authorization": `Bearer ${SERVICE_ROLE_KEY}`,
      "apikey": SERVICE_ROLE_KEY
    },
    body: JSON.stringify({ set_code, debug })
  });
  if (!res.ok) throw new Error(`import-prices ${set_code} -> ${res.status}: ${await res.text()}`);
  return await res.json().catch(()=> ({}));
}

// ---- HTTP handler ----------------------------------------------------------

export default {
  async fetch(req: Request) {
    try {
      const { fix = false, throttleMs = 150, only } = await req.json().catch(()=> ({}));

      const apiSetIds = Array.isArray(only) && only.length
        ? Array.from(new Set(only.map(String))).sort()
        : await listAllSetIds();

      const dbSetCodes = await listDbSetCodesFromCardPrints();

      const api = new Set(apiSetIds);
      const db  = new Set(dbSetCodes);

      const missing = apiSetIds.filter(id => !db.has(id));
if (body.fix) {
  const throttleMs = Number(body.throttleMs ?? 200);
  const results: Array<any> = [];
  for (const sid of missing) {
    try {
      const r = await importOne(sid, false);
      results.push({
        set: sid,
        status: r.status,
        fetched: r.body?.fetched ?? 0,
        inserted: r.body?.inserted ?? 0,
        note: r.body?.note,
      });
    } catch (e) {
      results.push({ set: sid, error: String(e) });
    }
    await new Promise(r => setTimeout(r, throttleMs));
  }
  return new Response(JSON.stringify({ ok: true, tried: results.length, results }), {
    headers: { "Content-Type": "application/json" },
  });
}
      const extra   = dbSetCodes.filter(code => !api.has(code));

      // Optional: auto-fix by seeding prices for missing sets
      let fixTried = 0, fixOk = 0;
      if (fix && missing.length) {
        for (const id of missing) {
          fixTried++;
          try {
            const r = await runImportPrices(id, false);
            if (typeof r?.fetched === "number") fixOk++;
          } catch { /* count as failure */ }
          if (throttleMs > 0) await new Promise(r => setTimeout(r, throttleMs));
        }
      }

      const report = {
        ok: true,
        total_api: apiSetIds.length,
        total_db: dbSetCodes.length,
        missing_count: missing.length,
        extra_count: extra.length,
        missing,
        extra,
        fix: { requested: !!fix, tried: fixTried, ok: fixOk }
      };

      await writeAudit({ run_at: new Date().toISOString(), ...report });
      return new Response(JSON.stringify(report), { headers: { "content-type": "application/json" }});
    } catch (e) {
      return new Response(JSON.stringify({ ok: false, error: String(e) }), { status: 500, headers: { "content-type": "application/json" }});
    }
  }
};

